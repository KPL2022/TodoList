<!DOCTYPE html>

<html>
  <head>
    <title>KPL Todo List</title>
    <style>
      ul li {
        list-style-type: none;
        padding: 0;
        margin: 0;
        border: 1px solid gray;
        border-radius: 5px;
      }

      * {

        box-sizing: border-box;
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        border-width: 1px;
        border-radius: 5px;
      }

      .header {

        background-color: bisque;
        text-align: center;
        padding: 20px;
        font-size: x-large;
      }

      .global-actions {

        display: flex;

        flex-flow: row wrap;
        padding: 15px;
      }

      .ga-option {

        margin-right: 5px;
      }

      .core-disp-lists {

        display: flex;

        flex-flow: row wrap;
        justify-content: space-around;
      }

      .disp-list {

        flex: 50%;
        padding: 10px;
      }

      .footer-img {

        width: 23%;
        margin: auto;
        float: right;        
      }

    </style>
  </head>
  <body class="body">

    <div class="header">My Tasks</div>

    <div class="global-actions">

      <!-- button based removeAll -->
      <button id="removeall-button" class="ga-option">Remove all todos</button>

      <!-- button based toggleAll -->
      <button id="toggleall-button" class="ga-option">Toggle all todos</button>

      <!-- button based add -->
      <button id="add-button" class="ga-option">Add a todo</button>

      <input id="add-input" placeholder="new todo text" class="ga-option">
    </div>

    <div>think about metrics to evaluate approach to improve as a programmer</div>

    <div class="core-disp-lists">
      <!-- main todo list container -->
      <ul id="todo-list" class="disp-list">
        Current todos
      </ul>

      <!-- completed items list container -->
      <ul id="completed-list" class="disp-list">
        Completed Items
      </ul>
    </div>

    <div class="footer">

      <img src="ghibli.jpg" class="footer-img">
    </div>

    <!-- js related -->
    <script>
      
      var cid = 0;
      var cCnt = 0;
      var cLim = 3;

      function createEntryBook(baseCol) {

        var enBk = {

          collectionInternal: baseCol,

          addEntry: function (lstEntry) {

            baseCol.add(lstEntry);
            persistentCoreV1.syncAdd(lstEntry);
          },

          rmvEntry: function (lstEntry) {

            baseCol.delete(lstEntry);
            persistentCoreV1.syncRemove(lstEntry);
          },

          clearAllEntries: function () {

            baseCol.clear();
            persistentCoreV1.resetRemote();
          },

          accessCol: function () {

            return baseCol;
          }
        };

        return enBk;
      }

      function createCore(todosContainer) {

        var res = {

          entryBook: createEntryBook(todosContainer),
          
          syncUpdate: function(lstEntry) {

                        var entryId = 't' + lstEntry.id;
                        var newVal = lstEntry.getTxt() + "-" + lstEntry.getStatus();

                        document.cookie = entryId + "=" + newVal + ";";
                      },

          syncAdd: function(lstEntry) {

                     var entryId = 't' + cid;
                     lstEntry.id = cid;
                     cid++;
                     document.cookie = "tcid=" + cid + ";";
                     cCnt++;
                     var entryVal = lstEntry.getTxt() + "-" + lstEntry.getStatus();

                     document.cookie = entryId + "=" + entryVal + ";";
                   },

          syncRemove: function(lstEntry) {

                        var entryId = 't' + lstEntry.id;
                        document.cookie = entryId + "=" + ";";
                        cCnt--;
                      },

          resetRemote: function() {

                         // TODO:
                       },

          loadRecords: function() {

                         var cks = decodeURIComponent(document.cookie).split(';');
                         
                         initFromCookies(cks);
                       }
        };

        return res;
      }

      function initFromCookies(cookies) {

        for (var i = 0; i < cookies.length; i++) {

          var id = cookies[i].substring(cookies[i].indexOf('t') + 1, cookies[i].indexOf('='));
          var entryInfo = cookies[i].substring(cookies[i].indexOf('=') + 1);

          if (id === 'cid') {

            cid = Number(entryInfo);
          } else if (entryInfo !== '') {

            var entryPair = entryInfo.split('-');
            var lstEntry = createTodoEntry(entryPair[0], entryPair[1] === 'true');
            lstEntry.id = id;

            persistentCoreV1.entryBook.collectionInternal.add(lstEntry);

            // update display
            var todoList = document.getElementById('todo-list');
            todoList.appendChild(lstEntry.disp);
          } else {

            // recycle unused id, it needs to be implemented if we 
            // keep going that far with this cookie system
          }
        }
      }

      // chose set for obj reference access scheme, 
      // no order constraint, set contains all todo entry objs
      const persistentCoreV1 = createCore(new Set());

      persistentCoreV1.loadRecords();

      /**
       * basic display setup work, hooking up buttons, also functions that
       * operate on multiple todo entries go here
      */

      // button based removeAll
      var rmvAllBtn = document.getElementById('removeall-button');
      rmvAllBtn.addEventListener('click', removeAll);

      // button based toggleAll
      var togAllBtn = document.getElementById('toggleall-button');
      togAllBtn.addEventListener('click', toggleAll);

      // button based add
      var addBtn = document.getElementById('add-button');
      var addInput = document.getElementById('add-input');
      addBtn.addEventListener('click', add);

      // remove all todo entries from disp and backend container
      function removeAll() {

        var todoList = document.getElementById('todo-list');
        var compList = document.getElementById('completed-list');

        persistentCoreV1.entryBook.accessCol().forEach(todoEntry => {
          
          if (todoEntry.getStatus()) {

            compList.removeChild(todoEntry.disp);
          } else {

            todoList.removeChild(todoEntry.disp);
          }
        });

        persistentCoreV1.entryBook.clearAllEntries();
      }

      /**
       * toggles all todo entries with rules:
       * 
       * 1. none or some entries checked -> make all entries checked
       * 2. if all entries checked -> uncheck all entries
       * 
       * o(n) 2-pass b/c status depends on col based property, need 1-pass first
      */
      function toggleAll() {

        var priorStatus = true;

        persistentCoreV1.entryBook.accessCol().forEach(todoEntry => {

          priorStatus = priorStatus && todoEntry.getStatus();
        });

        batchSetCompletionStatus(!priorStatus);
      }

      // set completion status of entire container with status given
      function batchSetCompletionStatus(status) {

        var todoList = document.getElementById('todo-list');
        var compList = document.getElementById('completed-list');

        persistentCoreV1.entryBook.accessCol().forEach(todoEntry => {
          
          if (todoEntry.getStatus() != status) {

            todoEntry.editStatus(status);
            todoEntry.disp.children[0].innerText = getStatusStr(status);

            moveItemBetween(todoEntry.disp, status, todoList, compList);
          }
        });
      }
      
      /**
       * setting up handlers that respond to user actions
      */

      // 2-layer wrapper to provide event handler with obj ref of todo entry to work on,
      // and addr of action to take
      function contxtAction(entryRef) {
        
        var lstEntry = entryRef;

        function actionWrapper(action) {

          function applyContxtToAction() {

            action(lstEntry);
          }

          return applyContxtToAction;
        }

        return actionWrapper;
      }

      // remove the given todo entry both from container and display
      function rmv(lstEntry) {

        persistentCoreV1.entryBook.rmvEntry(lstEntry);

        // remove related disp
        if (lstEntry.getStatus()) {

          document.getElementById('completed-list').removeChild(lstEntry.disp);
        } else {

          document.getElementById('todo-list').removeChild(lstEntry.disp);
        }
      }

      // setting up display to receive user edit contents
      function editRequest(lstEntry) {

        // access edit input field and set current todoText as starting text
        lstEntry.disp.children[1].value = lstEntry.getTxt();
        
        // remove original text from display
        var linTxt = lstEntry.disp.childNodes[1];
        linTxt.textContent = '';

        // switch disp between edit button & edi field + confirm button
        lstEntry.disp.children[3].style.display = 'none';
        lstEntry.disp.children[1].style.display = '';
        lstEntry.disp.children[2].style.display = '';
      }

      // reflecting user changes to container and display
      function editConfirm(lstEntry) {

        // get replacement txt from input field
        var dIn = lstEntry.disp.children[1];
        var replacement = dIn.value;

        // update todo text and renew displayed data
        lstEntry.editTxt(replacement);
        lstEntry.disp.childNodes[1].textContent = replacement;
        dIn.style.display = 'none';
        lstEntry.disp.children[2].style.display = 'none';

        lstEntry.disp.children[3].style.display = '';
      }

      // toggle the given todo entry
      function toggle(lstEntry) {

        lstEntry.editStatus(!lstEntry.getStatus());

        // update button icon
        var togBtn = lstEntry.disp.children[0];
        togBtn.innerText = getStatusStr(lstEntry.getStatus());

        // swap between todo and completed list based on status
        var todoList = document.getElementById('todo-list');
        var compList = document.getElementById('completed-list');

        // move entry between lists based on completion status
        moveItemBetween(lstEntry.disp, lstEntry.getStatus(), todoList, compList);
      }

      function moveItemBetween(disp, completed, todoList, compList) {

        if (completed) {

          todoList.removeChild(disp);
          compList.appendChild(disp);
        } else {

          compList.removeChild(disp);
          todoList.appendChild(disp);
        }
      }

      /**
       * creating todo entry objs here, and implant needed info for handlers to respond to
       * user actions with closure
      */

      // add new todo entry
      function add() {
        
        if (cCnt > cLim) {

          alert("too many todos, try removing entries before adding more");
          return;
        }

        // get user text and create todo entry
        var lstEntry = createTodoEntry(addInput.value, false);
        
        // clean up input field
        addInput.value = "";

        // update container
        persistentCoreV1.entryBook.addEntry(lstEntry);

        // update display
        var todoList = document.getElementById('todo-list');
        todoList.appendChild(lstEntry.disp);
      }

      // create todo entry obj, and set up event handlers to handle user actions
      function createTodoEntry(newItemText, initStatus) {

        var lstEntry = { todoText: newItemText, 
                         completed: initStatus,
                         disp: document.createElement("li")};

        var wrapperObj = createCoherentWrapper(lstEntry);

        setupVisuals(wrapperObj);

         return wrapperObj; 
      }

      function createCoherentWrapper(lstEntry) {

        var res = {disp: lstEntry.disp};

        var editTxt = function(newTxt) {
                        
                        lstEntry.todoText = newTxt;
                        persistentCoreV1.syncUpdate(res);
                      };

        var getTxt = function() {return lstEntry.todoText;};

        var editStatus = function(newStatus) {
                           
                           lstEntry.completed = newStatus;
                           persistentCoreV1.syncUpdate(res);
                         };

        var getStatus = function() {return lstEntry.completed;};

        res.editTxt = editTxt;
        res.getTxt = getTxt;
        res.editStatus = editStatus;
        res.getStatus = getStatus;

        return res;
      }
      
      function setupVisuals(lstEntry) {

        var perform = contxtAction(lstEntry);

        // add toggle button to disp
        lstEntry.disp.appendChild(createButton(getStatusStr(lstEntry.getStatus()), perform(toggle), false));
        
        // create text node and input field for edits
        lstEntry.disp.appendChild(document.createTextNode(lstEntry.getTxt()));
        lstEntry.disp.appendChild(createInputField(true));

        // add edit confirm button to disp
        lstEntry.disp.appendChild(createButton('confirm', perform(editConfirm), true));

        // add edit request button to disp
        lstEntry.disp.appendChild(createButton('edit', perform(editRequest), false));
        
        // add remove button to disp
        lstEntry.disp.appendChild(createButton('remove', perform(rmv), false));
      }

      function createButton(txt, handlerFx, hide) {

        var btn = document.createElement('button');
        btn.innerText = txt;
        btn.addEventListener('click', handlerFx);

        if (hide) {

          btn.style.display = 'none';
        }

        return btn;
      }

      function createInputField(hide) {
    
        // start by generating an edit platform with unique id
        var dIn = document.createElement('input');

        if (hide) {
          dIn.style.display = 'none';
        }

        return dIn;
      }

      function getStatusStr(status) {

        if (status) {

          return "[v^]";
        } else {

          return "[ ]";
        }
      }
    </script>
  </body>

</html>